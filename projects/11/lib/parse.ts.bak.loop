import { Keyword, Symbol } from "./consts";
import { Token, TokenType } from "./tokenize";

export type ReturnType = Keyword.Void;

export interface DoStatement {
	type: "doStatement";
}

export interface ReturnStatement {
	type: "returnStatement";
}

export type Statement = DoStatement | ReturnStatement;

export interface FunctionParameter {}

export type FunctionBody = readonly Statement[];

export interface Function {
	readonly type: "function";
	readonly name: string;
	readonly parameters: readonly FunctionParameter[];
	readonly returnType: ReturnType;
	readonly body: FunctionBody;
}

export interface Class {
	readonly type: "class";
	readonly name: string;
	readonly body: Function;
}

export type Ast = Class | Function;

export type ParseResult<T> = [T, readonly Token[]];

const parseDoStatement = (
	tokens: readonly Token[]
): ParseResult<DoStatement> => [
	{
		type: "doStatement",
	},
	tokens,
];

const parseReturnStatement = (
	tokens: readonly Token[]
): ParseResult<ReturnStatement> => [
	{
		type: "returnStatement",
	},
	tokens,
];

const parseStatement = ([
	token,
	...tokens
]: readonly Token[]): ParseResult<Statement> => {
	switch (token.value) {
		case Keyword.Do:
			return parseDoStatement(tokens);
		case Keyword.Return:
			return parseReturnStatement(tokens);
		default:
			throw new Error(`Unknown statement: ${tokens[0]}`);
	}
};

const parseReturnType = (tokens: readonly Token[]): ParseResult<ReturnType> => [
	Keyword.Void,
	tokens,
];

const parseFunctionName = (tokens: readonly Token[]): ParseResult<string> => [
	"",
	tokens,
];

const parseFunctionParameters = (
	tokens: readonly Token[]
): ParseResult<readonly FunctionParameter[]> => [[], tokens];

const isEndFunctionBody = (tokens: readonly Token[]): boolean =>
	tokens[0].type === TokenType.Symbol && tokens[0].value === ";";

const parseFunctionBody = (
	tokens: readonly Token[]
): ParseResult<FunctionBody> => {
	const loop = (
		statements: readonly Statement[],
		tokensBeforeStatement: readonly Token[]
	): ParseResult<FunctionBody> => {
		if (isEndFunctionBody(tokensBeforeStatement)) {
			return [statements, tokensBeforeStatement];
		}
		const [statement, tokensAfterStatement] = parseStatement(
			tokensBeforeStatement
		);
		return loop([...statements, statement], tokensAfterStatement);
	};
	return loop([], tokens);
};

const parseClassName = (tokens: readonly Token[]): ParseResult<string> => [
	"",
	tokens,
];

const parseClassBody = (tokens: readonly Token[]): ParseResult<Function> => {
	const [returnType, tokensAfterReturnType] = parseReturnType(tokens);
	const [name, tokensAfterName] = parseFunctionName(tokensAfterReturnType);
	const [parameters, tokensAfterParameters] =
		parseFunctionParameters(tokensAfterName);
	const [body, tokensAfterBody] = parseFunctionBody(tokensAfterParameters);
	return [
		{
			type: "function",
			name,
			parameters,
			returnType,
			body,
		},
		tokensAfterBody,
	];
};

const parseClass = (tokens: readonly Token[]): ParseResult<Class> => {
	const [name, tokensAfterName] = parseClassName(tokens);
	const [body, tokensAfterBody] = parseClassBody(tokensAfterName);
	return [
		{
			type: "class",
			name,
			body,
		},
		tokensAfterBody,
	];
};

export const parse = (tokens: readonly Token[]): Ast => {
	const [result, tokensAfterClass] = parseClass(tokens);
	if (tokensAfterClass.length > 0) {
		console.log("UNPARSED TOKENS", tokensAfterClass);
	}
	return result;
};
